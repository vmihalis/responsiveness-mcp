---
phase: 08-cli-interface
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/cli/types.ts
  - src/cli/validation.ts
  - src/cli/commands.ts
autonomous: true

must_haves:
  truths:
    - "URL validation accepts http and https protocols"
    - "URL validation rejects invalid URLs with helpful message"
    - "Concurrency validation accepts 1-50 range"
    - "Wait validation accepts positive numbers"
    - "Device filter flags are mutually exclusive by union"
    - "Commander parses all required arguments and options"
  artifacts:
    - path: "src/cli/types.ts"
      provides: "CLIOptions interface for typed option handling"
      min_lines: 15
    - path: "src/cli/validation.ts"
      provides: "URL, concurrency, wait, device filter validation"
      exports: ["validateUrl", "validateConcurrency", "validateWait", "selectDevices"]
      min_lines: 50
    - path: "src/cli/commands.ts"
      provides: "Commander program with all arguments and options"
      exports: ["program", "createProgram"]
      min_lines: 40
  key_links:
    - from: "src/cli/commands.ts"
      to: "commander"
      via: "import { Command }"
      pattern: "new Command"
    - from: "src/cli/validation.ts"
      to: "src/devices/index.js"
      via: "device selection import"
      pattern: "getDevices|getDevicesByCategory"
---

<objective>
Create CLI types, validation functions, and Commander command definitions for responsive-capture.

Purpose: Establish the foundation for CLI argument parsing with proper validation and helpful error messages. All flags from requirements (CLI-01 through CLI-04, LOAD-05, DEV-03) must be defined.

Output: Three files providing typed options, input validation, and Commander program configuration.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-cli-interface/08-RESEARCH.md

# Existing code to integrate with
@src/cli/index.ts
@src/devices/index.ts
@src/config/defaults.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CLI types</name>
  <files>src/cli/types.ts</files>
  <action>
Create CLI-specific TypeScript types:

```typescript
// src/cli/types.ts
import type { DeviceCategory } from '../devices/types.js';

/**
 * Parsed CLI options from Commander
 */
export interface CLIOptions {
  /** Multiple page paths to capture */
  pages?: string[];
  /** Parallel capture limit (default: 10) */
  concurrency?: number;
  /** Wait buffer after page load in ms (default: 500) */
  wait?: number;
  /** Only capture phone devices */
  phonesOnly?: boolean;
  /** Only capture tablet devices */
  tabletsOnly?: boolean;
  /** Only capture desktop devices */
  desktopsOnly?: boolean;
  /** Output directory override */
  output?: string;
}

/**
 * Validated CLI configuration ready for execution
 */
export interface ValidatedConfig {
  baseUrl: URL;
  pages: string[];
  concurrency: number;
  waitBuffer: number;
  deviceCategories: DeviceCategory[] | null; // null = all devices
  outputDir: string;
}
```

Include JSDoc comments on all properties.
  </action>
  <verify>
`npx tsc --noEmit` passes - types compile without errors
  </verify>
  <done>
src/cli/types.ts exists with CLIOptions and ValidatedConfig interfaces exported
  </done>
</task>

<task type="auto">
  <name>Task 2: Create validation functions</name>
  <files>src/cli/validation.ts</files>
  <action>
Create input validation functions with clear error messages:

```typescript
// src/cli/validation.ts
import type { Device, DeviceCategory } from '../devices/types.js';
import type { CLIOptions, ValidatedConfig } from './types.js';
import { getDevices, getDevicesByCategory } from '../devices/index.js';
import { defaultConfig } from '../config/defaults.js';

/**
 * Validate and parse URL string
 * @throws Error with helpful message if invalid
 */
export function validateUrl(urlString: string): URL {
  try {
    const url = new URL(urlString);
    if (!['http:', 'https:'].includes(url.protocol)) {
      throw new Error(
        `Invalid protocol: ${url.protocol}. URL must use http:// or https://`
      );
    }
    return url;
  } catch (error) {
    if (error instanceof TypeError) {
      throw new Error(
        `Invalid URL: "${urlString}"\nExample: http://localhost:3000 or https://example.com`
      );
    }
    throw error;
  }
}

/**
 * Validate concurrency value (1-50)
 */
export function validateConcurrency(value: number | undefined): number {
  const concurrency = value ?? defaultConfig.concurrency;
  if (!Number.isInteger(concurrency) || concurrency < 1 || concurrency > 50) {
    throw new Error(
      `Concurrency must be an integer between 1 and 50, got: ${value}`
    );
  }
  return concurrency;
}

/**
 * Validate wait buffer value (positive number)
 */
export function validateWait(value: number | undefined): number {
  const wait = value ?? defaultConfig.waitBuffer;
  if (!Number.isFinite(wait) || wait < 0) {
    throw new Error(
      `Wait buffer must be a positive number in milliseconds, got: ${value}`
    );
  }
  return wait;
}

/**
 * Select devices based on filter flags
 * Returns union of all specified categories, or all devices if none specified
 */
export function selectDevices(options: CLIOptions): Device[] {
  const categories: DeviceCategory[] = [];

  if (options.phonesOnly) categories.push('phones');
  if (options.tabletsOnly) categories.push('tablets');
  if (options.desktopsOnly) categories.push('pc-laptops');

  // No filters = all devices
  if (categories.length === 0) {
    return getDevices();
  }

  // Union of specified categories
  const devices: Device[] = [];
  for (const category of categories) {
    devices.push(...getDevicesByCategory(category));
  }
  return devices;
}

/**
 * Resolve page paths from optional path argument and --pages option
 * Returns array of paths to capture (default: ['/'])
 */
export function resolvePages(
  pathArg: string | undefined,
  pagesOption: string[] | undefined
): string[] {
  // --pages takes precedence
  if (pagesOption && pagesOption.length > 0) {
    return pagesOption.map(p => p.startsWith('/') ? p : `/${p}`);
  }

  // Single path argument
  if (pathArg) {
    const path = pathArg.startsWith('/') ? pathArg : `/${pathArg}`;
    return [path];
  }

  // Default to root
  return ['/'];
}

/**
 * Build full URL from base URL and path
 */
export function buildFullUrl(baseUrl: URL, path: string): string {
  const url = new URL(baseUrl.href);
  url.pathname = path;
  return url.href;
}

/**
 * Validate all CLI inputs and return validated config
 */
export function validateConfig(
  urlArg: string,
  pathArg: string | undefined,
  options: CLIOptions
): ValidatedConfig {
  const baseUrl = validateUrl(urlArg);
  const pages = resolvePages(pathArg, options.pages);
  const concurrency = validateConcurrency(options.concurrency);
  const waitBuffer = validateWait(options.wait);

  // Determine device categories (null = all)
  const categories: DeviceCategory[] = [];
  if (options.phonesOnly) categories.push('phones');
  if (options.tabletsOnly) categories.push('tablets');
  if (options.desktopsOnly) categories.push('pc-laptops');

  return {
    baseUrl,
    pages,
    concurrency,
    waitBuffer,
    deviceCategories: categories.length > 0 ? categories : null,
    outputDir: options.output ?? defaultConfig.outputDir,
  };
}
```

Each validation function should:
- Return valid value or throw descriptive error
- Include example in error message where helpful
- Handle undefined using defaults from config
  </action>
  <verify>
`npx tsc --noEmit` passes - validation module compiles
  </verify>
  <done>
src/cli/validation.ts exports validateUrl, validateConcurrency, validateWait, selectDevices, resolvePages, buildFullUrl, validateConfig
  </done>
</task>

<task type="auto">
  <name>Task 3: Create Commander program definition</name>
  <files>src/cli/commands.ts</files>
  <action>
Create Commander program with all arguments and options:

```typescript
// src/cli/commands.ts
import { Command } from 'commander';

/**
 * Create Commander program with all CLI arguments and options
 * Separated from action handler for testability
 */
export function createProgram(): Command {
  const program = new Command()
    .name('responsive-capture')
    .description('Capture responsive screenshots across 50+ device viewports')
    .version('1.0.0')

    // Required: base URL
    .argument('<url>', 'Base URL to capture (e.g., http://localhost:3000)')

    // Optional: single page path
    .argument('[path]', 'Page path to capture (default: /)')

    // Multiple pages (variadic, must be after other options in usage)
    .option('--pages <paths...>', 'Multiple page paths to capture')

    // Execution options
    .option(
      '-c, --concurrency <number>',
      'Number of parallel captures (1-50)',
      parseInt
    )
    .option(
      '-w, --wait <ms>',
      'Wait buffer after page load in milliseconds',
      parseInt
    )

    // Device filters (can combine for union)
    .option('--phones-only', 'Only capture phone devices')
    .option('--tablets-only', 'Only capture tablet devices')
    .option('--desktops-only', 'Only capture desktop/laptop devices')

    // Output
    .option('-o, --output <dir>', 'Output directory (default: ./screenshots)')

    // Help examples
    .addHelpText('after', `
Examples:
  $ responsive-capture http://localhost:3000
  $ responsive-capture http://localhost:3000 /about
  $ responsive-capture https://example.com --pages /home /about /contact
  $ responsive-capture http://localhost:3000 --phones-only --concurrency 5
  $ responsive-capture http://localhost:3000 --wait 1000 --output ./my-screenshots
`);

  return program;
}

// Default program instance (will be connected to action handler in index.ts)
export const program = createProgram();
```

Commander options mapping:
- `--pages <paths...>` -> variadic string array
- `-c, --concurrency <number>` -> parseInt coercion
- `-w, --wait <ms>` -> parseInt coercion
- `--phones-only`, `--tablets-only`, `--desktops-only` -> boolean flags
- `-o, --output <dir>` -> string

Note: Action handler will be added in Plan 02 to keep this plan focused on parsing.
  </action>
  <verify>
`node -e "import('./dist/cli/commands.js').then(m => m.program.parse(['node', 'cli', '--help']))"` after build shows help text with all options
  </verify>
  <done>
src/cli/commands.ts exports createProgram() and program instance with URL argument, path argument, and all flags (--pages, --concurrency, --wait, --phones-only, --tablets-only, --desktops-only, --output, --help)
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npm run build` succeeds
2. `npx tsc --noEmit` passes
3. All three files exist with documented exports
4. `node dist/cli/commands.js --help` shows all flags
</verification>

<success_criteria>
- CLIOptions interface matches all Commander options
- Validation functions provide helpful error messages
- Commander program defines all required arguments and options
- --help shows usage examples
- All code compiles without TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/08-cli-interface/08-01-SUMMARY.md`
</output>

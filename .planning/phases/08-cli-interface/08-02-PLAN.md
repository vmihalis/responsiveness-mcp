---
phase: 08-cli-interface
plan: 02
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - src/cli/actions.ts
  - src/cli/index.ts
autonomous: true

must_haves:
  truths:
    - "responsive-capture <url> captures all devices for root path"
    - "responsive-capture <url> /path captures specific page"
    - "responsive-capture <url> --pages /a /b captures multiple pages"
    - "Browser cleanup happens on success and failure"
    - "Invalid input shows helpful error and exits with code 2"
  artifacts:
    - path: "src/cli/actions.ts"
      provides: "runCapture action handler orchestrating capture pipeline"
      exports: ["runCapture"]
      min_lines: 80
    - path: "src/cli/index.ts"
      provides: "CLI entry point wiring program to action handler"
      min_lines: 20
  key_links:
    - from: "src/cli/actions.ts"
      to: "src/engine/index.js"
      via: "BrowserManager and captureAllDevices imports"
      pattern: "BrowserManager|captureAllDevices"
    - from: "src/cli/actions.ts"
      to: "src/output/index.js"
      via: "createOutputDirectory and saveAllScreenshots imports"
      pattern: "createOutputDirectory|saveAllScreenshots"
    - from: "src/cli/actions.ts"
      to: "src/output/reporter.js"
      via: "generateReport and prepareScreenshotsForReport imports"
      pattern: "generateReport|prepareScreenshotsForReport"
    - from: "src/cli/index.ts"
      to: "src/cli/commands.js"
      via: "program import"
      pattern: "program\\.action"
---

<objective>
Create the CLI action handler that orchestrates the capture pipeline and wire it to the Commander program.

Purpose: Connect all prior phase modules (devices, engine, output, reporter) into a working CLI. This is the integration layer that makes the tool usable.

Output: Action handler in actions.ts and updated entry point in index.ts.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-cli-interface/08-RESEARCH.md

# From Plan 01
@src/cli/types.ts
@src/cli/validation.ts
@src/cli/commands.ts

# Integration points
@src/engine/index.ts
@src/output/index.ts
@src/output/reporter.ts
@src/devices/index.ts
@src/config/defaults.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create action handler</name>
  <files>src/cli/actions.ts</files>
  <action>
Create the main action handler that orchestrates the capture pipeline:

```typescript
// src/cli/actions.ts
import pc from 'picocolors';
import type { CLIOptions } from './types.js';
import {
  validateUrl,
  validateConcurrency,
  validateWait,
  selectDevices,
  resolvePages,
  buildFullUrl,
} from './validation.js';
import { BrowserManager, captureAllDevices } from '../engine/index.js';
import { createOutputDirectory, saveAllScreenshots } from '../output/index.js';
import { generateReport, prepareScreenshotsForReport } from '../output/reporter.js';
import { defaultConfig } from '../config/defaults.js';
import type { ReportData } from '../output/types.js';

/**
 * Main CLI action handler
 * Orchestrates: validation -> devices -> capture -> save -> report
 */
export async function runCapture(
  urlArg: string,
  pathArg: string | undefined,
  options: CLIOptions
): Promise<void> {
  const startTime = Date.now();

  // 1. Validate inputs (throws on invalid)
  const baseUrl = validateUrl(urlArg);
  const pages = resolvePages(pathArg, options.pages);
  const concurrency = validateConcurrency(options.concurrency);
  const waitBuffer = validateWait(options.wait);

  // 2. Select devices based on filters
  const devices = selectDevices(options);

  if (devices.length === 0) {
    throw new Error('No devices selected. Check your filter flags.');
  }

  console.log(pc.cyan(`\nCapturing ${devices.length} devices across ${pages.length} page(s)...`));
  console.log(pc.dim(`URL: ${baseUrl.href}`));
  console.log(pc.dim(`Pages: ${pages.join(', ')}`));
  console.log(pc.dim(`Concurrency: ${concurrency}`));

  // 3. Create output directory
  const outputDir = await createOutputDirectory({
    baseDir: options.output ?? defaultConfig.outputDir,
  });
  console.log(pc.dim(`Output: ${outputDir}`));

  // 4. Launch browser
  const manager = new BrowserManager();

  try {
    await manager.launch();

    // 5. Capture each page
    for (const page of pages) {
      const fullUrl = buildFullUrl(baseUrl, page);
      console.log(pc.cyan(`\nCapturing: ${fullUrl}`));

      let completed = 0;
      const result = await captureAllDevices(
        manager,
        fullUrl,
        devices,
        {
          timeout: defaultConfig.timeout,
          waitBuffer,
        },
        {
          concurrency,
          onProgress: (done, total, res) => {
            completed = done;
            const status = res.success ? pc.green('OK') : pc.red('FAIL');
            // Simple progress output (Phase 9 will add spinner)
            process.stdout.write(`\r  ${done}/${total} ${res.deviceName} ${status}  `);
          },
        }
      );

      // Clear progress line
      process.stdout.write('\r' + ' '.repeat(60) + '\r');

      console.log(pc.dim(`  ${result.successCount} succeeded, ${result.failureCount} failed`));

      // 6. Save screenshots
      const saveResult = await saveAllScreenshots(result.results, devices, outputDir);
      console.log(pc.dim(`  ${saveResult.savedCount} files saved`));

      // 7. Generate report
      const screenshots = prepareScreenshotsForReport(result.results, devices);
      const duration = Date.now() - startTime;

      const reportData: ReportData = {
        url: fullUrl,
        capturedAt: new Date().toLocaleString(),
        duration,
        deviceCount: result.successCount,
        files: [], // Files list populated by saveResult but not used in template
      };

      const reportPath = await generateReport(reportData, screenshots, outputDir);
      console.log(pc.green(`\nReport saved: ${reportPath}`));
    }

    const totalDuration = Date.now() - startTime;
    console.log(pc.green(`\nDone in ${Math.round(totalDuration / 1000)}s`));

  } finally {
    // Always cleanup browser
    await manager.close();
  }
}

/**
 * Handle CLI errors with appropriate exit codes
 */
export function handleError(error: unknown): never {
  if (error instanceof Error) {
    console.error(pc.red('\nError: ') + error.message);

    // Check for common error types
    if (error.message.includes('Invalid URL') || error.message.includes('Invalid protocol')) {
      console.error(pc.dim('\nHint: URL must start with http:// or https://'));
      process.exit(2); // Argument error
    }

    if (error.message.includes('Concurrency') || error.message.includes('Wait buffer')) {
      process.exit(2); // Argument error
    }

    // General error
    process.exit(1);
  }

  console.error(pc.red('\nUnknown error:'), error);
  process.exit(1);
}
```

Key behaviors:
- Validate ALL inputs before starting any expensive operations
- Show progress for each page capture (simple output, Phase 9 adds spinner)
- Always close browser in finally block (even on error)
- Exit code 2 for argument errors, 1 for runtime errors
- Use picocolors for styled output (already installed)
  </action>
  <verify>
`npx tsc --noEmit` passes - action handler compiles
  </verify>
  <done>
src/cli/actions.ts exports runCapture and handleError with full pipeline orchestration
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire entry point to action handler</name>
  <files>src/cli/index.ts</files>
  <action>
Update CLI entry point to connect program with action handler:

```typescript
#!/usr/bin/env node
// CLI entry point for responsive-capture

import { program } from './commands.js';
import { runCapture, handleError } from './actions.js';
import type { CLIOptions } from './types.js';

// Connect action handler to program
program.action(async (url: string, path: string | undefined, options: CLIOptions) => {
  try {
    await runCapture(url, path, options);
  } catch (error) {
    handleError(error);
  }
});

// Parse arguments and run
program.parse();
```

The entry point should be minimal:
- Import program and action handler
- Wire action to program
- Parse and run
- Let handleError manage exit codes
  </action>
  <verify>
After `npm run build`:
1. `node dist/cli/index.js --help` shows help with all options
2. `node dist/cli/index.js invalid-url` shows helpful error and exits non-zero
3. `node dist/cli/index.js http://localhost:3000 --phones-only --concurrency 2` attempts capture (will fail if no server, but shows CLI is working)
  </verify>
  <done>
src/cli/index.ts wires program.action() to runCapture with error handling
  </done>
</task>

<task type="auto">
  <name>Task 3: Add CLI exports to index</name>
  <files>src/cli/index.ts</files>
  <action>
Add re-exports for testability (types and functions that tests might need):

At the end of src/cli/index.ts, add:

```typescript
// Re-exports for testing and programmatic use
export type { CLIOptions, ValidatedConfig } from './types.js';
export {
  validateUrl,
  validateConcurrency,
  validateWait,
  selectDevices,
  resolvePages,
  buildFullUrl,
  validateConfig,
} from './validation.js';
export { createProgram, program } from './commands.js';
export { runCapture, handleError } from './actions.js';
```

This allows tests to import from `./cli/index.js` rather than individual files.
  </action>
  <verify>
`npx tsc --noEmit` passes - exports are valid
  </verify>
  <done>
src/cli/index.ts re-exports types and functions for testing
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npm run build` succeeds
2. `npm run typecheck` passes (or `npx tsc --noEmit`)
3. `node dist/cli/index.js --help` shows full usage with examples
4. `node dist/cli/index.js not-a-url` shows "Invalid URL" error and exits 2
5. `node dist/cli/index.js http://localhost --concurrency abc` shows concurrency error
6. `node dist/cli/index.js http://localhost:3000 --phones-only` attempts capture (fails gracefully if no server)
</verification>

<success_criteria>
- CLI entry point is thin orchestration layer
- Action handler coordinates all modules (devices, engine, output, reporter)
- Browser cleanup happens in finally block (even on error)
- Error messages are helpful with hints
- Exit codes: 0 (success), 1 (runtime error), 2 (argument error)
- All re-exports enable unit testing
</success_criteria>

<output>
After completion, create `.planning/phases/08-cli-interface/08-02-SUMMARY.md`
</output>

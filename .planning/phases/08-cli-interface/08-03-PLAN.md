---
phase: 08-cli-interface
plan: 03
type: execute
wave: 3
depends_on: ["08-02"]
files_modified:
  - src/cli/__tests__/validation.test.ts
  - src/cli/__tests__/commands.test.ts
autonomous: true

must_haves:
  truths:
    - "URL validation tests cover valid http/https, invalid URLs, wrong protocols"
    - "Concurrency validation tests cover valid range, out of range, non-integer"
    - "Wait validation tests cover valid values, negative, non-numeric"
    - "Device selection tests cover single filter, multiple filters (union), no filters"
    - "Command parsing tests cover required URL, optional path, all options"
  artifacts:
    - path: "src/cli/__tests__/validation.test.ts"
      provides: "Unit tests for validation functions"
      min_lines: 100
    - path: "src/cli/__tests__/commands.test.ts"
      provides: "Unit tests for Commander argument parsing"
      min_lines: 60
  key_links:
    - from: "src/cli/__tests__/validation.test.ts"
      to: "src/cli/validation.js"
      via: "import validation functions"
      pattern: "validateUrl|validateConcurrency|validateWait|selectDevices"
    - from: "src/cli/__tests__/commands.test.ts"
      to: "src/cli/commands.js"
      via: "import createProgram"
      pattern: "createProgram"
---

<objective>
Create comprehensive unit tests for CLI validation functions and Commander argument parsing.

Purpose: Ensure CLI correctly handles all input combinations, edge cases, and error conditions. Tests verify validation logic independently from integration tests.

Output: Two test files covering validation.ts and commands.ts modules.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-cli-interface/08-RESEARCH.md

# Code under test (from Plans 01-02)
@src/cli/types.ts
@src/cli/validation.ts
@src/cli/commands.ts

# Test patterns from existing tests
@src/devices/devices.test.ts
@src/output/__tests__/organizer.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create validation tests</name>
  <files>src/cli/__tests__/validation.test.ts</files>
  <action>
Create comprehensive unit tests for validation functions:

```typescript
// src/cli/__tests__/validation.test.ts
import { describe, it, expect } from 'vitest';
import {
  validateUrl,
  validateConcurrency,
  validateWait,
  selectDevices,
  resolvePages,
  buildFullUrl,
} from '../validation.js';
import { getDevices, getDevicesByCategory } from '../../devices/index.js';

describe('validateUrl', () => {
  describe('valid URLs', () => {
    it('accepts http URL', () => {
      const result = validateUrl('http://localhost:3000');
      expect(result).toBeInstanceOf(URL);
      expect(result.href).toBe('http://localhost:3000/');
    });

    it('accepts https URL', () => {
      const result = validateUrl('https://example.com');
      expect(result).toBeInstanceOf(URL);
      expect(result.protocol).toBe('https:');
    });

    it('accepts URL with path', () => {
      const result = validateUrl('http://localhost:3000/app');
      expect(result.pathname).toBe('/app');
    });

    it('accepts URL with port', () => {
      const result = validateUrl('http://localhost:8080');
      expect(result.port).toBe('8080');
    });

    it('accepts IP address URL', () => {
      const result = validateUrl('http://192.168.1.1:3000');
      expect(result.hostname).toBe('192.168.1.1');
    });
  });

  describe('invalid URLs', () => {
    it('rejects malformed URL', () => {
      expect(() => validateUrl('not-a-url')).toThrow(/Invalid URL/);
    });

    it('rejects URL without protocol', () => {
      expect(() => validateUrl('localhost:3000')).toThrow(/Invalid URL/);
    });

    it('rejects empty string', () => {
      expect(() => validateUrl('')).toThrow(/Invalid URL/);
    });

    it('provides helpful example in error', () => {
      expect(() => validateUrl('bad')).toThrow(/Example:/);
    });
  });

  describe('protocol validation', () => {
    it('rejects ftp protocol', () => {
      expect(() => validateUrl('ftp://example.com')).toThrow(/Invalid protocol/);
    });

    it('rejects file protocol', () => {
      expect(() => validateUrl('file:///path/to/file')).toThrow(/Invalid protocol/);
    });

    it('includes protocol in error message', () => {
      expect(() => validateUrl('ftp://example.com')).toThrow(/ftp:/);
    });
  });
});

describe('validateConcurrency', () => {
  describe('valid values', () => {
    it('accepts minimum value (1)', () => {
      expect(validateConcurrency(1)).toBe(1);
    });

    it('accepts maximum value (50)', () => {
      expect(validateConcurrency(50)).toBe(50);
    });

    it('accepts middle value', () => {
      expect(validateConcurrency(10)).toBe(10);
    });

    it('returns default when undefined', () => {
      expect(validateConcurrency(undefined)).toBe(10);
    });
  });

  describe('invalid values', () => {
    it('rejects zero', () => {
      expect(() => validateConcurrency(0)).toThrow(/between 1 and 50/);
    });

    it('rejects negative', () => {
      expect(() => validateConcurrency(-1)).toThrow(/between 1 and 50/);
    });

    it('rejects over maximum', () => {
      expect(() => validateConcurrency(51)).toThrow(/between 1 and 50/);
    });

    it('rejects non-integer', () => {
      expect(() => validateConcurrency(5.5)).toThrow(/integer/);
    });

    it('includes provided value in error', () => {
      expect(() => validateConcurrency(100)).toThrow(/100/);
    });
  });
});

describe('validateWait', () => {
  describe('valid values', () => {
    it('accepts zero', () => {
      expect(validateWait(0)).toBe(0);
    });

    it('accepts positive integer', () => {
      expect(validateWait(1000)).toBe(1000);
    });

    it('accepts positive float', () => {
      expect(validateWait(500.5)).toBe(500.5);
    });

    it('returns default when undefined', () => {
      expect(validateWait(undefined)).toBe(500);
    });
  });

  describe('invalid values', () => {
    it('rejects negative', () => {
      expect(() => validateWait(-100)).toThrow(/positive number/);
    });

    it('rejects NaN', () => {
      expect(() => validateWait(NaN)).toThrow(/positive number/);
    });

    it('rejects Infinity', () => {
      expect(() => validateWait(Infinity)).toThrow(/positive number/);
    });
  });
});

describe('selectDevices', () => {
  it('returns all devices when no filters', () => {
    const devices = selectDevices({});
    const allDevices = getDevices();
    expect(devices.length).toBe(allDevices.length);
  });

  it('returns only phones with --phones-only', () => {
    const devices = selectDevices({ phonesOnly: true });
    const phones = getDevicesByCategory('phones');
    expect(devices.length).toBe(phones.length);
    expect(devices.every(d => d.category === 'phones')).toBe(true);
  });

  it('returns only tablets with --tablets-only', () => {
    const devices = selectDevices({ tabletsOnly: true });
    const tablets = getDevicesByCategory('tablets');
    expect(devices.length).toBe(tablets.length);
    expect(devices.every(d => d.category === 'tablets')).toBe(true);
  });

  it('returns only desktops with --desktops-only', () => {
    const devices = selectDevices({ desktopsOnly: true });
    const desktops = getDevicesByCategory('pc-laptops');
    expect(devices.length).toBe(desktops.length);
    expect(devices.every(d => d.category === 'pc-laptops')).toBe(true);
  });

  it('returns union with multiple filters', () => {
    const devices = selectDevices({ phonesOnly: true, tabletsOnly: true });
    const phones = getDevicesByCategory('phones');
    const tablets = getDevicesByCategory('tablets');
    expect(devices.length).toBe(phones.length + tablets.length);
  });

  it('returns all three categories when all filters specified', () => {
    const devices = selectDevices({
      phonesOnly: true,
      tabletsOnly: true,
      desktopsOnly: true,
    });
    const allDevices = getDevices();
    expect(devices.length).toBe(allDevices.length);
  });
});

describe('resolvePages', () => {
  it('returns ["/"] when no path or pages', () => {
    expect(resolvePages(undefined, undefined)).toEqual(['/']);
  });

  it('uses path argument when provided', () => {
    expect(resolvePages('/about', undefined)).toEqual(['/about']);
  });

  it('adds leading slash to path if missing', () => {
    expect(resolvePages('about', undefined)).toEqual(['/about']);
  });

  it('prefers --pages over path argument', () => {
    expect(resolvePages('/ignored', ['/a', '/b'])).toEqual(['/a', '/b']);
  });

  it('adds leading slash to pages if missing', () => {
    expect(resolvePages(undefined, ['a', 'b'])).toEqual(['/a', '/b']);
  });

  it('handles empty pages array', () => {
    expect(resolvePages(undefined, [])).toEqual(['/']);
  });
});

describe('buildFullUrl', () => {
  it('combines base URL and path', () => {
    const base = new URL('http://localhost:3000');
    expect(buildFullUrl(base, '/about')).toBe('http://localhost:3000/about');
  });

  it('replaces existing path', () => {
    const base = new URL('http://localhost:3000/old');
    expect(buildFullUrl(base, '/new')).toBe('http://localhost:3000/new');
  });

  it('preserves port', () => {
    const base = new URL('http://localhost:8080');
    expect(buildFullUrl(base, '/test')).toBe('http://localhost:8080/test');
  });

  it('preserves protocol', () => {
    const base = new URL('https://example.com');
    expect(buildFullUrl(base, '/secure')).toBe('https://example.com/secure');
  });
});
```

Test categories:
- validateUrl: valid URLs, invalid URLs, protocol validation
- validateConcurrency: valid range, out of range, edge cases
- validateWait: valid values, invalid values
- selectDevices: single filter, multiple filters (union), no filters
- resolvePages: path arg, pages option, defaults, slash handling
- buildFullUrl: base + path combination
  </action>
  <verify>
`npm test -- src/cli/__tests__/validation.test.ts` - all tests pass
  </verify>
  <done>
src/cli/__tests__/validation.test.ts exists with tests for all validation functions
  </done>
</task>

<task type="auto">
  <name>Task 2: Create command parsing tests</name>
  <files>src/cli/__tests__/commands.test.ts</files>
  <action>
Create unit tests for Commander argument parsing:

```typescript
// src/cli/__tests__/commands.test.ts
import { describe, it, expect, beforeEach } from 'vitest';
import { createProgram } from '../commands.js';
import type { Command } from 'commander';

describe('CLI Command Parsing', () => {
  let program: Command;

  beforeEach(() => {
    // Create fresh program for each test (no action handler attached)
    program = createProgram();
    // Suppress exit on error for testing
    program.exitOverride();
    // Suppress output
    program.configureOutput({
      writeOut: () => {},
      writeErr: () => {},
    });
  });

  describe('required URL argument', () => {
    it('parses URL as first argument', () => {
      program.parse(['node', 'cli', 'http://localhost:3000']);
      expect(program.args[0]).toBe('http://localhost:3000');
    });

    it('throws when URL missing', () => {
      expect(() => program.parse(['node', 'cli'])).toThrow();
    });
  });

  describe('optional path argument', () => {
    it('parses path as second argument', () => {
      program.parse(['node', 'cli', 'http://localhost', '/about']);
      expect(program.args[1]).toBe('/about');
    });

    it('path is undefined when not provided', () => {
      program.parse(['node', 'cli', 'http://localhost']);
      expect(program.args[1]).toBeUndefined();
    });
  });

  describe('--pages option', () => {
    it('parses single page', () => {
      program.parse(['node', 'cli', 'http://localhost', '--pages', '/home']);
      expect(program.opts().pages).toEqual(['/home']);
    });

    it('parses multiple pages', () => {
      program.parse(['node', 'cli', 'http://localhost', '--pages', '/a', '/b', '/c']);
      expect(program.opts().pages).toEqual(['/a', '/b', '/c']);
    });
  });

  describe('--concurrency option', () => {
    it('parses short flag -c', () => {
      program.parse(['node', 'cli', 'http://localhost', '-c', '5']);
      expect(program.opts().concurrency).toBe(5);
    });

    it('parses long flag --concurrency', () => {
      program.parse(['node', 'cli', 'http://localhost', '--concurrency', '20']);
      expect(program.opts().concurrency).toBe(20);
    });

    it('is undefined when not provided', () => {
      program.parse(['node', 'cli', 'http://localhost']);
      expect(program.opts().concurrency).toBeUndefined();
    });
  });

  describe('--wait option', () => {
    it('parses short flag -w', () => {
      program.parse(['node', 'cli', 'http://localhost', '-w', '1000']);
      expect(program.opts().wait).toBe(1000);
    });

    it('parses long flag --wait', () => {
      program.parse(['node', 'cli', 'http://localhost', '--wait', '2000']);
      expect(program.opts().wait).toBe(2000);
    });
  });

  describe('device filter flags', () => {
    it('parses --phones-only', () => {
      program.parse(['node', 'cli', 'http://localhost', '--phones-only']);
      expect(program.opts().phonesOnly).toBe(true);
    });

    it('parses --tablets-only', () => {
      program.parse(['node', 'cli', 'http://localhost', '--tablets-only']);
      expect(program.opts().tabletsOnly).toBe(true);
    });

    it('parses --desktops-only', () => {
      program.parse(['node', 'cli', 'http://localhost', '--desktops-only']);
      expect(program.opts().desktopsOnly).toBe(true);
    });

    it('allows multiple device filters', () => {
      program.parse(['node', 'cli', 'http://localhost', '--phones-only', '--tablets-only']);
      expect(program.opts().phonesOnly).toBe(true);
      expect(program.opts().tabletsOnly).toBe(true);
    });

    it('all filters are undefined when not specified', () => {
      program.parse(['node', 'cli', 'http://localhost']);
      expect(program.opts().phonesOnly).toBeUndefined();
      expect(program.opts().tabletsOnly).toBeUndefined();
      expect(program.opts().desktopsOnly).toBeUndefined();
    });
  });

  describe('--output option', () => {
    it('parses short flag -o', () => {
      program.parse(['node', 'cli', 'http://localhost', '-o', './my-output']);
      expect(program.opts().output).toBe('./my-output');
    });

    it('parses long flag --output', () => {
      program.parse(['node', 'cli', 'http://localhost', '--output', '/tmp/screenshots']);
      expect(program.opts().output).toBe('/tmp/screenshots');
    });
  });

  describe('combined options', () => {
    it('parses all options together', () => {
      program.parse([
        'node', 'cli',
        'http://localhost:3000',
        '/start',
        '--pages', '/a', '/b',
        '-c', '5',
        '-w', '1000',
        '--phones-only',
        '-o', './out',
      ]);

      expect(program.args[0]).toBe('http://localhost:3000');
      expect(program.args[1]).toBe('/start');
      expect(program.opts().pages).toEqual(['/a', '/b']);
      expect(program.opts().concurrency).toBe(5);
      expect(program.opts().wait).toBe(1000);
      expect(program.opts().phonesOnly).toBe(true);
      expect(program.opts().output).toBe('./out');
    });
  });

  describe('help and version', () => {
    it('has responsive-capture as program name', () => {
      expect(program.name()).toBe('responsive-capture');
    });

    it('has version set', () => {
      expect(program.version()).toBe('1.0.0');
    });

    it('has description set', () => {
      expect(program.description()).toContain('responsive');
    });
  });
});
```

Key patterns:
- Use createProgram() for fresh instance per test
- Use exitOverride() to prevent process.exit in tests
- Use configureOutput() to suppress help/error output
- Test each option in isolation and in combination
- Verify undefined when options not provided
  </action>
  <verify>
`npm test -- src/cli/__tests__/commands.test.ts` - all tests pass
  </verify>
  <done>
src/cli/__tests__/commands.test.ts exists with tests for all argument and option parsing
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npm test -- src/cli/__tests__/` runs all CLI tests
2. All validation tests pass
3. All command parsing tests pass
4. `npm test` runs full test suite (existing + new tests)
5. Test count increases by ~40-50 tests
</verification>

<success_criteria>
- Validation tests cover: valid inputs, invalid inputs, edge cases, error messages
- Command tests cover: required args, optional args, all options, combined options
- Tests use fresh program instance per test (no state leakage)
- All tests pass with `npm test`
- Coverage includes error paths (rejects, throws)
</success_criteria>

<output>
After completion, create `.planning/phases/08-cli-interface/08-03-SUMMARY.md`
</output>
